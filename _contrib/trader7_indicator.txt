//@version=6
indicator(title = 'Trader7 Main', shorttitle='T7_MAIN', overlay=true, max_bars_back=300,max_boxes_count=500, max_lines_count=500, max_labels_count=500)

import TradersReality/Traders_Reality_Lib/2 as trLib

f_security(_symbol, _res, _src, _repaint) =>
    request.security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

// Function to draw dashed lines for W and M formations
f_draw_dashed_line(start_index, end_index, level, line_color) =>
    line.new(x1=start_index, y1=level, x2=end_index, y2=level, color=line_color, width=1, style=line.style_dashed)

// Function to draw transparent overlays for W and M formations
f_draw_overlay(start_index, end_index, top_level, bottom_level, overlay_color) =>
    box.new(left=start_index,top=top_level,right=end_index,bottom=bottom_level,border_color=color.new(overlay_color, 0),bgcolor=color.new(overlay_color, 80))

// Detect W Formation
f_is_w_formation(_high, _low, _close) =>
    _low[2] > _low[1] and _low[1] < _low and _high[1] > _high[2] and _high > _high[1] and _close > _close[1]

is_w_formation = f_is_w_formation(high, low, close)

// Add Labels for W Formation
if is_w_formation
    label.new(x = bar_index, y = na, text = "W Formation", color = color.new(color.green, 90), textcolor = color.white, style = label.style_label_down, yloc = yloc.belowbar, size = size.normal)
    f_draw_dashed_line(bar_index[2], bar_index, low, color.new(color.green, 0))
    f_draw_overlay(bar_index[2], bar_index, high[2], low[2], color.new(color.green, 80))

// Function to detect M Formation

// Detect M Formation
f_is_m_formation(_high, _low, _close) =>
    _high[2] < _high[1] and _high[1] > _high and _low[1] < _low[2] and _low < _low[1] and _close < _close[1]

is_m_formation = f_is_m_formation(high, low, close)

// Add Labels for M Formation
if is_m_formation
    label.new(x = bar_index, y = na, text = "M Formation", color = color.new(color.red, 90), textcolor = color.white, style = label.style_label_up, yloc = yloc.abovebar, size = size.normal)
    f_draw_dashed_line(bar_index[2], bar_index, high, color.new(color.red, 0))
    f_draw_overlay(bar_index[2], bar_index, high[2], low[2], color.new(color.red, 80))

// Function to check for significant moves
f_is_significant_move(_high, _low, _atr) =>
    (_high - _low) > _atr

// Function to check for high volume
f_is_high_volume(_volume, _avg_volume) =>
    _volume > _avg_volume * 2

// Function to detect Tattoo Pattern
f_is_tattoo_pattern(_high, _low, _close) =>
    _low[2] > _low[1] and _low[1] < _low and _high[1] > _high[2] and _high > _high[1] and _close > _close[1] and _close[1] < _close[2]

is_tattoo_pattern = f_is_tattoo_pattern(high, low, close)

// Add Labels for Tattoo Pattern
if is_tattoo_pattern
    label.new(x = bar_index, y = na, text = "Tattoo Pattern", color = color.new(color.blue, 90), textcolor = color.white, style = label.style_label_down, yloc = yloc.belowbar, size = size.normal)

// Function to detect Vector Candles
f_is_vector_candle(_volume, _avg_volume, _close, _open) =>
    _volume > _avg_volume * 2 and _close > _open

// Calculate average volume
avg_volume = ta.sma(volume, 14)

// Function to add labels for key levels
f_add_label(index, price, label_text, label_color) =>
    label.new(x=index, y=price, text=label_text, style=label.style_label_down, color=color.new(label_color, 70), textcolor=color.white)

// Function to detect Weekly Cycle
// Weekly Cycle Logic
f_detect_weekly_cycle(_high, _low, _close, _volume, _avg_volume, _current_level) =>
    new_level = _current_level
    is_w_formation = _low[2] > _low[1] and _low[1] < _low and _high[1] > _high[2] and _high > _high[1] and _close > _close[1]
    is_m_formation = _high[2] < _high[1] and _high[1] > _high and _low[1] < _low[2] and _low < _low[1] and _close < _close[1]

    // Vector candle detection
    is_green_vector = _volume > _avg_volume * 2 and _close > open
    is_red_vector = _volume > _avg_volume * 2 and _close < open

    if is_w_formation and na(new_level)
        new_level := 1  // Start of the cycle (Level 1)
        f_add_label(bar_index, low, "W - Level 1", color.green)
    else if new_level == 1 and is_green_vector
        new_level := 2  // Level 2
        f_add_label(bar_index, high, "Level 2", color.green)
    else if new_level == 2 and is_green_vector
        new_level := 3  // Level 3
        f_add_label(bar_index, high, "Level 3", color.green)
    else if new_level == 3 and is_m_formation
        new_level := 4  // Peak Formation
        f_add_label(bar_index, high, "M - Peak Formation", color.red)
    else if new_level == 4 and is_red_vector
        new_level := -3  // Reversing to Level 3
        f_add_label(bar_index, low, "Reverse Level 3", color.red)
    else if new_level == -3 and is_red_vector
        new_level := -2  // Reversing to Level 2
        f_add_label(bar_index, low, "Reverse Level 2", color.red)
    else if new_level == -2 and is_red_vector
        new_level := -1  // Reversing to Level 1
        f_add_label(bar_index, low, "Reverse Level 1", color.red)
    else if new_level == -1
        new_level := na  // End of the cycle

    new_level

//is_weekly_cycle = f_is_weekly_cycle(high, low, close, volume, avg_volume)

// Detect and highlight weekly cycle
var int current_level = na
current_level := f_detect_weekly_cycle(high, low, close, volume, avg_volume, current_level)

// Alert Conditions
alertcondition(is_w_formation, title="W Formation Detected", message="A W formation has been detected on the chart.")
alertcondition(is_m_formation, title="M Formation Detected", message="An M formation has been detected on the chart.")
alertcondition(is_tattoo_pattern, title="Tattoo Pattern Detected", message="A Tattoo pattern has been detected on the chart.")
// alertcondition(is_weekly_cycle, title="Weekly Cycle Detected", message="A Weekly cycle has been detected on the chart.")
// config.pine

// Misc
bool show = true

bool overrideSym = input.bool(group='PVSRA Override', title='Override chart symbol?', defval=false, inline='pvsra')
string pvsraSym = input.string(group='PVSRA Override', title='', defval='INDEX:BTCUSD', tooltip='You can use INDEX:BTCUSD or you can combine multiple feeds, for example BINANCE:BTCUSDT+COINBASE:BTCUSD. Note that adding too many will slow things down.', inline='pvsra')

// Function to fetch PVSRA data
pvsraVolume(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', [volume, high, low, close, open], barmerge.gaps_off, barmerge.lookahead_off)

// Label offsets
levelStart = timeframe.isseconds == true or timeframe.isminutes == true and timeframe.multiplier < 5 ? time('D') : time('D') - 86400 * 1000

labelOffsetInput = input.int(group='Label offsets', title='General', defval=12, inline='labeloffset1')
pivotOffsetInput = input.int(group='Label offsets', title='Pivots', defval=6, inline='labeloffset1')
adrOffsetInput = input.int(group='Label offsets', title='ADR', defval=12, inline='labeloffset1')
adrOffsetInput50 = input.int(group='Label offsets', title='50% ADR', defval=12, inline='labeloffset1')
rdOffsetInput = input.int(group='Label offsets', title='RD/W', defval=24, inline='labeloffset1')
rdOffsetInput50 = input.int(group='Label offsets', title='50% RD/W', defval=24, inline='labeloffset1')
pivotLabelXOffset = time_close + pivotOffsetInput * timeframe.multiplier * 60 * 1000

// PVSRA Colors
color redVectorColor = input.color(title='Vector: Red', group='PVSRA Colors', defval=color.red, inline='vectors')
color greenVectorColor = input.color(title='Green', group='PVSRA Colors', defval=color.lime, inline='vectors')
color violetVectorColor = input.color(title='Violet', group='PVSRA Colors', defval=color.fuchsia, inline='vectors')
color blueVectorColor = input.color(title='Blue', group='PVSRA Colors', defval=color.blue, inline='vectors', tooltip='Bull bars are green and bear bars are red when the bar is with volume >= 200% of the average volume of the 10 previous bars, or bars where the product of candle spread x candle volume is >= the highest for the 10 previous bars.\n Bull bars are blue and bear are violet when the bar is with with volume >= 150% of the average volume of the 10 previous bars.')
color regularCandleUpColor = input.color(title='Regular: Up Candle', group='PVSRA Colors', defval=#999999, inline='nonVectors')
color regularCandleDownColor = input.color(title='Down Candle', group='PVSRA Colors', defval=#4d4d4d, inline='nonVectors', tooltip='Bull bars are light gray and bear are dark gray when none of the red/green/blue/violet vector conditions are met.')

// EMAs
showEmas = input.bool(group='EMAs', title='Show EMAs?', defval=true, inline='showemas')
labelEmas = input.bool(group='EMAs', title='EMA Labels?', defval=false, inline='showemas')
oneEmaColor = input.color(group='EMAs', title='EMA Color: 5', defval=color.rgb(254, 234, 74, 0), inline='emacolors')
twoEmaColor = input.color(group='EMAs', title='13', defval=color.rgb(253, 84, 87, 0), inline='emacolors')
threeEmaColor = input.color(group='EMAs', title='50', defval=color.rgb(31, 188, 211, 0), inline='emacolors')
fourEmaColor = input.color(group='EMAs', title='200', defval=color.rgb(255, 255, 255, 0), inline='emacolors')
fiveEmaColor = input.color(group='EMAs', title='800', defval=color.rgb(50, 34, 144, 0), inline='emacolors')
emaCloudColor = input.color(group='EMAs', title='EMA Cloud', defval=color.rgb(155, 47, 174, 60), inline='emacloud')
emaCloudBorderColor = input.color(group='EMAs', title='Border', defval=color.rgb(18, 137, 123, 100), inline='emacloud')

// Pivot Points
showLevelOnePivotPoints = input.bool(group='Pivot Points', title='Show Level: 1 R/S?', defval=false, inline='pivotlevels')
showLevelTwoPivotPoints = input.bool(group='Pivot Points', title='2 R/S?', defval=false, inline='pivotlevels')
showLevelThreePivotPoints = input.bool(group='Pivot Points', title=' 3 R/S?', defval=false, inline='pivotlevels')
showPivotLabels = input.bool(group='Pivot Points', title='Show labels?', defval=true, inline='pivotlevels')
string rsStyleX = input.string(group='Pivot Points', defval='Dashed', title='R/S Levels Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='pivotcolorsRS')
rsStyle = rsStyleX == 'Dotted' ? line.style_dotted : (rsStyleX == 'Dashed' ? line.style_dashed : (rsStyleX == 'Solid' ? line.style_solid : line.style_dashed))

activeM = input.bool(group='Pivot Points', title='Show M levels?', defval=true, inline='mlevels')
showMLabels = input.bool(group='Pivot Points', title='Labels?', defval=true, inline='mlevels')
extendPivots = input.bool(group='Pivot Points', title='Extend lines in both directions?', defval=false)
pivotColor = input.color(group='Pivot Points', title='Colors: Pivot Point', defval=color.rgb(254, 234, 78, 50), inline='pivotcolors')
pivotLabelColor = input.color(group='Pivot Points', title='Pivot Point Label', defval=color.rgb(254, 234, 78, 50), inline='pivotcolors')
mColor = input.color(group='Pivot Points', title='Colors: M Levels', defval=color.rgb(255, 255, 255, 50), inline='pivotcolors1')
mLabelColor = input.color(group='Pivot Points', title='M Levels Label', defval=color.rgb(255, 255, 255, 50), inline='pivotcolors1')
string mStyleX = input.string(group='Pivot Points', defval='Dashed', title='M Levels Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='pivotcolors2')
mStyle = mStyleX == 'Dotted' ? line.style_dotted : (mStyleX == 'Dashed' ? line.style_dashed : (mStyleX == 'Solid' ? line.style_solid : line.style_dashed))

// Daily and Weekly High/Low
showDayHighLow = input.bool(group="Yesterday's and Last Week's High/low", title='Show Hi/Lo: Daily?', defval=true, inline='highlow')
dailyHiLoColor = color.new(color.blue, 50)
showWeekHighLow = input.bool(group="Yesterday's and Last Week's High/low", title='Weekly?', defval=true, inline='highlow')
weeklyHiLoColor = color.new(color.green, 60)
showDayHighLowLabels = input.bool(group="Yesterday's and Last Week's High/low", title='Show labels?', defval=true, inline='highlow')

// ADR, AWR, AMR
showADR = input.bool(group='Average Daily Range - ADR', title='Show ADR?', defval=true, inline='adr')
showADRDO = input.bool(group='Average Daily Range - ADR', title='Use Daily Open (DO) calc?', defval=false, inline='adr', tooltip='Measure the ADR from the daily open. This will make the ADR static throughout the day. ADR is usually measured taking today high and low. Since todays high and low will change throughout the day, some might prefer to have a static range instead.')
showADRLabels = input.bool(group='Average Daily Range - ADR', title='Labels?', defval=true, inline='adr1')
showADRRange = input.bool(group='Average Daily Range - ADR', title='Range label?', defval=false, inline='adr1')
showADR50 = input.bool(group='Average Daily Range - ADR', title='Show 50% ADR?', defval=false, inline='adr1')
aDRRange = input.int(group='Average Daily Range - ADR', title='ADR length (days)?', defval=14, minval=1, maxval=31, step=1, inline='adr2', tooltip="Defaults taken from mt4. This defines how many days back to take into consideration when calculating the ADR")
adrColor = input.color(group='Average Daily Range - ADR', title='ADR Color', defval=color.new(color.silver, 50), inline='adr3')
string adrStyleX = input.string(group='Average Daily Range - ADR', defval='Dotted', title='ADR Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='adr3')
adrStyle = adrStyleX == 'Dotted' ? line.style_dotted : (adrStyleX == 'Dashed' ? line.style_dashed : (adrStyleX == 'Solid' ? line.style_solid : line.style_dotted))

showAWR = input.bool(group='Average Weekly Range - AWR', title='Show AWR?', defval=false, inline='awr')
showAWRWO = input.bool(group='Average Weekly Range - AWR', title='Use Weekly Open (WO) calc?', defval=false, inline='awr', tooltip='Measure the AWR from the weekly open. This will make the AWR static throughout the week. AWR is usually measured taking this weeks high and low. Since this weeks high and low will change throughout the week, some might prefer to have a static range instead.')
showAWRLabels = input.bool(group='Average Weekly Range - AWR', title='Labels?', defval=true, inline='awr1')
showAWRRange = input.bool(group='Average Weekly Range - AWR', title='Range label?', defval=false, inline='awr1')
showAWR50 = input.bool(group='Average Weekly Range - AWR', title='Show 50% AWR?', defval=false, inline='awr1')
aWRRange = input.int(group='Average Weekly Range - AWR', title='AWR length (weeks)?', defval=4, minval=1, maxval=52, step=1, inline='awr2', tooltip="Defaults taken from mt4. This defines how many weeks back to take into consideration when calculating the AWR")
awrColor = input.color(group='Average Weekly Range - AWR', title='AWR Color', defval=color.new(color.orange, 50), inline='awr3')
string awrStyleX = input.string(group='Average Weekly Range - AWR', defval='Dotted', title='AWR Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='awr3')
awrStyle = awrStyleX == 'Dotted' ? line.style_dotted : (awrStyleX == 'Dashed' ? line.style_dashed : (awrStyleX == 'Solid' ? line.style_solid : line.style_dotted))

showAMR = input.bool(group='Average Monthly Range - AMR', title='Show AMR?', defval=false, inline='amr')
showAMRMO = input.bool(group='Average Monthly Range - AMR', title='Use Monthly Open (MO) calc?', defval=false, inline='amr',tooltip='Measure the AMR from the monthly open. This will make the AMR static throughout the month. AMR is usually measured taking this months high and low. Since this months high and low will change throughout the month, some might prefer to have a static range instead.')
showAMRLabels = input.bool(group='Average Monthly Range - AMR', title='Labels?', defval=true, inline='amr1')
showAMRRange = input.bool(group='Average Monthly Range - AMR', title='Range label?', defval=false, inline='amr1')
showAMR50 = input.bool(group='Average Monthly Range - AMR', title='Show 50% AMR?', defval=false, inline='amr1')
aMRRange = input.int(group='Average Monthly Range - AMR', title='AMR length (months)?', defval=6, minval=1, maxval=12, step=1, inline='amr2', tooltip="Defaults taken from mt4. This defines how many months back to take into consideration when calculating the AMR")
amrColor = input.color(group='Average Monthly Range - AMR', title='AMR Color', defval=color.new(color.red, 50), inline='amr3')
string amrStyleX = input.string(group='Average Monthly Range - AMR', defval='Dotted', title='AMR Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='amr3')
amrStyle = amrStyleX == 'Dotted' ? line.style_dotted : (amrStyleX == 'Dashed' ? line.style_dashed : (amrStyleX == 'Solid' ? line.style_solid : line.style_dotted))

// Range Daily/Weekly
showRD = input.bool(group='Range Daily Hi/Lo - RD Hi/Lo', title='Show RD?', defval=false, inline='rd')
showRDDO = input.bool(group='Range Daily Hi/Lo - RD Hi/Lo', title='Use Daily Open (DO) calc?', defval=false, inline='rd',tooltip='Measure the RD from the daily open. This will make the RD static throughout the day. RD is usually measured taking todays high and low. Since today high and low will change throughout the day, some might prefer to have a static range instead.')
showRDLabels = input.bool(group='Range Daily Hi/Lo - RD Hi/Lo', title='Labels?', defval=true, inline='rd1')
showRDRange = input.bool(group='Range Daily Hi/Lo - RD Hi/Lo', title='Range label?', defval=false, inline='rd1')
showRD50 = input.bool(group='Range Daily Hi/Lo - RD Hi/Lo', title='Show 50% RD?', defval=false, inline='rd1')
rdRange = input.int(group='Range Daily Hi/Lo - RD Hi/Lo', title='RD length (days)?', defval=15, minval=1, maxval=31, step=1, inline='rd2', tooltip="Defaults taken from Trader At Home PVSRA documentation. This defines how many days back to take into consideration when calculating the RD")
rdColor = input.color(group='Range Daily Hi/Lo - RD Hi/Lo', title='RD Color', defval=color.new(color.red, 30), inline='rd3')
string rdStyleX = input.string(group='Range Daily Hi/Lo - RD Hi/Lo', defval='Solid', title='RD Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='rd3')
rdStyle = rdStyleX == 'Dotted' ? line.style_dotted : (rdStyleX == 'Dashed' ? line.style_dashed : (rdStyleX == 'Solid' ? line.style_solid : line.style_dotted))

showRW = input.bool(group='Range Weekly Hi/Lo - RW Hi/Lo', title='Show RW?', defval=false, inline='rw')
showRWWO = input.bool(group='Range Weekly Hi/Lo - RW Hi/Lo', title='Use Weekly Open (WO) calc?', defval=false, inline='rw', tooltip='Measure the RW from the weekly open. This will make the RW static throughout the week. RW is usually measured taking this weeks high and low. Since this weeks high and low will change throughout the week, some might prefer to have a static range instead.')
showRWLabels = input.bool(group='Range Weekly Hi/Lo - RW Hi/Lo', title='Labels?', defval=true, inline='rw1')
showRWRange = input.bool(group='Range Weekly Hi/Lo - RW Hi/Lo', title='Range label?', defval=false, inline='rw1')
showRW50 = input.bool(group='Range Weekly Hi/Lo - RW Hi/Lo', title='Show 50% RW?', defval=false, inline='rw1')
rwRange = input.int(group='Range Weekly Hi/Lo - RW Hi/Lo', title='RW length (weeks)?', defval=13, minval=1, maxval=52, step=1, inline='rw2', tooltip="Defaults taken from Trader At Home PVSRA documentation. This defines how many weeks back to take into consideration when calculating the RW")
rwColor = input.color(group='Range Weekly Hi/Lo - RW Hi/Lo', title='RW Color', defval=color.new(color.blue, 30), inline='rw3')
string rwStyleX = input.string(group='Range Weekly Hi/Lo - RW Hi/Lo', defval='Solid', title='RW Line Style', options=['Dotted', 'Dashed', 'Solid'], inline='rw3')
rwStyle = rwStyleX == 'Dotted' ? line.style_dotted : (rwStyleX == 'Dashed' ? line.style_dashed : (rwStyleX == 'Solid' ? line.style_solid : line.style_dotted))

// ADR Table
showAdrTable = input.bool(group='ADR/ADRx3/AWR/AMR Table', title='Show ADR Table', inline='adrt', defval=true)
showAdrPips = input.bool(group='ADR/ADRx3/AWR/AMR Table', title='Show ADR PIPS', inline='adrt', defval=true) and showAdrTable
showAdrCurrency = input.bool(group='ADR/ADRx3/AWR/AMR Table', title='Show ADR Currency', inline='adrt', defval=false) and showAdrTable
showRDPips = input.bool(group='ADR/ADRx3/AWR/AMR Table', title='Show RD PIPS', inline='adrt', defval=false) and showAdrTable
showRDCurrency = input.bool(group='ADR/ADRx3/AWR/AMR Table', title='Show RD Currency', inline='adrt', defval=false) and showAdrTable
choiceAdrTable = input.string(group='ADR/ADRx3/AWR/AMR Table', title='ADR Table postion', inline='adrt', defval='top_right', options=['top_right', 'top_left', 'top_center', 'bottom_right', 'bottom_left', 'bottom_center'])
adrTableBgColor = input.color(group='ADR/ADRx3/AWR/AMR Table', title='ADR Table: Background Color', inline='adrtc', defval=color.rgb(93, 96, 107, 70))
adrTableTxtColor = input.color(group='ADR/ADRx3/AWR/AMR Table', title='Text Color', inline='adrtc', defval=color.rgb(31, 188, 211, 0))

// Market Sessions
showMarkets = input.bool(true, group='Market sessions', title='Show Market Sessions?', tooltip='Turn on or off all market sessions') and show
showMarketsWeekends = input.bool(false, group='Market sessions', title='Show Market Session on Weekends?', tooltip='Turn on or off market sessions in the weekends. Note do not turn this on for exchanges that dont have weekend data like OANDA') and show
string weekendSessions = ':1234567'
string noWeekendSessions = ':23456'

// London Session
showRectangle1 = input.bool(group='Market session: London (0800-1630 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session1conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel1 = input.bool(group='Market session: London (0800-1630 UTC+0) - DST Aware', defval=true, title='Label?', inline='session1conf') and showRectangle1 and showMarkets
showOr1 = input.bool(group='Market session: London (0800-1630 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session1conf', tooltip='This controls the shaded area for the session') and showRectangle1 and showMarkets
string sess1Label = input.string(group='Market session: London (0800-1630 UTC+0) - DST Aware', defval='London', title='Name:', inline='session1style')
color sess1col = input.color(group='Market session: London (0800-1630 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(120, 123, 134, 75), inline='session1style')
color sess1colLabel = input.color(group='Market session: London (0800-1630 UTC+0) - DST Aware', title='Label', defval=color.rgb(120, 123, 134, 0), inline='session1style')
string sess1TimeX = '0800-1630'
sess1Time = showMarketsWeekends ? sess1TimeX + weekendSessions : sess1TimeX + noWeekendSessions

// New York Session
showRectangle2 = input.bool(group='Market session: New York (1430-2100 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session2conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel2 = input.bool(group='Market session: New York (1430-2100 UTC+0) - DST Aware', defval=true, title='Label?', inline='session2conf') and showRectangle2 and showMarkets
showOr2 = input.bool(group='Market session: New York (1430-2100 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session2conf', tooltip='This controls the shaded area for the session') and showRectangle2 and showMarkets
string sess2Label = input.string(group='Market session: New York (1430-2100 UTC+0) - DST Aware', defval='NewYork', title='Name:', inline='session2style')
color sess2col = input.color(group='Market session: New York (1430-2100 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(251, 86, 91, 75), inline='session2style')
color sess2colLabel = input.color(group='Market session: New York (1430-2100 UTC+0) - DST Aware', title='Label', defval=color.rgb(253, 84, 87, 25), inline='session2style')
string sess2TimeX = '1430-2100'
sess2Time = showMarketsWeekends ? sess2TimeX + weekendSessions : sess2TimeX  + noWeekendSessions

// Tokyo Session
showRectangle3 = input.bool(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session3conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel3 = input.bool(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', defval=true, title='Label?', inline='session3conf') and showRectangle3 and showMarkets
showOr3 = input.bool(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session3conf', tooltip='This controls the shaded area for the session') and showRectangle3 and showMarkets
string sess3Label = input.string(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', defval='Tokyo', title='Name:', inline='session3style')
color sess3col = input.color(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(80, 174, 85, 75), inline='session3style')
color sess3colLabel = input.color(group='Market session: Tokyo (0000-0600 UTC+0) - DST Aware', title='Label', defval=color.rgb(80, 174, 85, 25), inline='session3style')
string sess3TimeX = '0000-0600'
sess3Time = showMarketsWeekends ? sess3TimeX + weekendSessions : sess3TimeX + noWeekendSessions

// Hong Kong Session
showRectangle4 = input.bool(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session4conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel4 = input.bool(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', defval=true, title='Label?', inline='session4conf') and showRectangle4 and showMarkets
showOr4 = input.bool(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session4conf', tooltip='This controls the shaded area for the session') and showRectangle4 and showMarkets
string sess4Label = input.string(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', defval='HongKong', title='Name:', inline='session4style')
color sess4col = input.color(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(128, 127, 23, 75), inline='session4style')
color sess4colLabel = input.color(group='Market session: Hong Kong (0130-0800 UTC+0) - DST Aware', title='Label', defval=color.rgb(128, 127, 23, 25), inline='session4style')
string sess4TimeX = '0130-0800'
sess4Time = showMarketsWeekends ? sess4TimeX + weekendSessions : sess4TimeX + noWeekendSessions

// Sydney Session
showRectangle5 = input.bool(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session5conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel5 = input.bool(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', defval=true, title='Label?', inline='session5conf') and showRectangle5 and showMarkets
showOr5 = input.bool(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session5conf', tooltip='This controls the shaded area for the session') and showRectangle5 and showMarkets
string sess5Label = input.string(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', defval='Sydney', title='Name:', inline='session5style')
color sess5col = input.color(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(37, 228, 123, 75), inline='session5style')
color sess5colLabel = input.color(group='Market session: Sydney (NZX+ASX 2200-0600 UTC+0) - DST Aware', title='Label', defval=color.rgb(37, 228, 123, 25), inline='session5style')
string sess5TimeX = '2200-0600'
sess5Time = showMarketsWeekends ? sess5TimeX + weekendSessions : sess5TimeX + noWeekendSessions

// EU Brinks Session
showRectangle6 = input.bool(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session6conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel6 = input.bool(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', defval=true, title='Label?', inline='session6conf') and showRectangle6 and showMarkets
showOr6 = input.bool(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session6conf', tooltip='This controls the shaded area for the session') and showRectangle6 and showMarkets
string sess6Label = input.string(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', defval='EU Brinks', title='Name:', inline='session6style')
color sess6col = input.color(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(255, 255, 255, 65), inline='session6style')
color sess6colLabel = input.color(group='Market session: EU Brinks (0800-0900 UTC+0) - DST Aware', title='Label', defval=color.rgb(255, 255, 255, 25), inline='session6style')
string sess6TimeX = '0800-0900'
sess6Time = showMarketsWeekends ? sess6TimeX + weekendSessions : sess6TimeX + noWeekendSessions

// US Brinks Session
showRectangle7 = input.bool(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', defval=true, title='Show: session?', inline='session7conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel7 = input.bool(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', defval=true, title='Label?', inline='session7conf') and showRectangle7 and showMarkets
showOr7 = input.bool(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session7conf', tooltip='This controls the shaded area for the session') and showRectangle7 and showMarkets
string sess7Label = input.string(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', defval='US Brinks', title='Name:', inline='session7style')
color sess7col = input.color(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(255, 255, 255, 65), inline='session7style')
color sess7colLabel = input.color(group='Market session: US Brinks (1400-1500 UTC+0) - DST Aware', title='Label', defval=color.rgb(255, 255, 255, 25), inline='session7style')
string sess7TimeX = '1400-1500'
sess7Time = showMarketsWeekends ? sess7TimeX + weekendSessions : sess7TimeX + noWeekendSessions

// Frankfurt Session
showRectangle8 = input.bool(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', defval=false, title='Show: session?', inline='session8conf', tooltip='If this checkbox is off, Label and Open Range have no effect') and showMarkets
showLabel8 = input.bool(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', defval=true, title='Label?', inline='session8conf') and showRectangle8 and showMarkets
showOr8 = input.bool(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', defval=true, title='Opening Range?', inline='session8conf', tooltip='This controls the shaded area for the session') and showRectangle8 and showMarkets
string sess8Label = input.string(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', defval='Frankfurt', title='Name:', inline='session8style')
color sess8col = input.color(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', title='Color: Box', defval=color.rgb(253, 152, 39, 75), inline='session8style')
color sess8colLabel = input.color(group='Market session: Frankfurt (0700-1630 UTC+0) - DST Aware', title='Label', defval=color.rgb(253, 152, 39, 25), inline='session8style')
string sess8TimeX = '0700-1630'
sess8Time = showMarketsWeekends ? sess8TimeX + weekendSessions : sess8TimeX + noWeekendSessions

// Psy Levels
showPsy = timeframe.isminutes and (timeframe.multiplier == 60 or timeframe.multiplier == 30 or timeframe.multiplier == 15 or timeframe.multiplier == 5 or timeframe.multiplier == 3 or timeframe.multiplier == 1)
showPsylevels = input.bool(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', defval=true, title='Show: Levels?', inline='psyconf') and showPsy
showPsylabel = input.bool(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', defval=true, title='Labels?', inline='psyconf', tooltip="The Psy High/Low will only show on these timeframes: 1h/30min/15min/5min/3min/1min. It is disabled on all others. This is because the calculation requires a candle to start at the correct time for Sydney/Tokyo but in other timeframes the data does not have values at the designated time for the Sydney/Tokyo sessions.") and showPsylevels
showAllPsy = input.bool(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', defval=false, title='Show historical psy levels?', inline='psyconf') and showPsylevels
color psyColH = input.color(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', title='Psy Hi Color', defval=color.new(color.orange, 30), inline='psyconf1')
color psyColL = input.color(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', title='Psy Low Color', defval=color.new(color.orange, 30), inline='psyconf1')
bool overridePsyType = input.bool(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', defval=false, title='Override PsyType', inline='psyconf12')
string psyTypeX = input.string(group='Weekly Psy Levels (valid tf 1h/30min/15min/5min/3min/1min)', defval='crypto', title='Psy calc type', options=['crypto', 'forex'], inline='psyconf12', tooltip="Selecting the override psy type lets you manually adjust the psy type otherwise it will be automatic. If the override psy type checkbox is of then this setting has no effect. usAre you looking at Crypto or Forex? Crypto calculations start with the Sydney session on Saturday night. Forex calculations start with the Tokyo session on Monday morning. Note some exchanges like Oanda do not have sessions on the weekends so you might be forced to select Forex for exchanges like Oanda even when looking at symbols like BITCOIN on Oanda.")
string psyType = overridePsyType ? psyTypeX : (syminfo.type == 'forex' ? 'forex' : 'crypto')

// DST Table
showDstTable = input.bool(group='Daylight Saving Time Info (DST)', title='Show DST Table : ', inline='dstt', defval=false)
choiceDstTable = input.string(group='Daylight Saving Time Info (DST)', title='DST Table postion', inline='dstt', defval='bottom_center', options=['top_right', 'top_left', 'top_center', 'bottom_right', 'bottom_left', 'bottom_center'])
dstTableBgColor = input.color(group='Daylight Saving Time Info (DST)', title='DST Table: Background Color', inline='dsttc', defval=color.rgb(93, 96, 107, 70))
dstTableTxtColor = input.color(group='Daylight Saving Time Info (DST)', title='Text Color', inline='dsttc', defval=color.rgb(31, 188, 211, 0))

// Misc
labelXOffset = time_close + labelOffsetInput * timeframe.multiplier * 60 * 1000
validTimeFrame = timeframe.isintraday == true
string rectStyle = input.string(group='Market sessions', defval='Dashed', title='Line style of Market Session hi/lo line', options=['Dashed', 'Solid'])
bool showVCZ = input.bool(true, 'Show VCZ?', group='Vector Candle Zones', inline="vczOn")
adrLabelXOffset = time_close + adrOffsetInput * timeframe.multiplier * 60 * 1000
adrLabelXOffset50 = time_close + adrOffsetInput50 * timeframe.multiplier * 60 * 1000

// Configuration for W and M formations
bool show_w_m_formations = input.bool(true, title="Show W and M Formations", group="Patterns")
float atr_threshold_multiplier = input.float(1.0, title="ATR Threshold Multiplier", group="Patterns")

// Configuration for vector candles
float volume_multiplier = input.float(2.0, title="Volume Multiplier for Vector Candles", group="Volume")
// ema.pine

// EMAs
oneEmaLength = 5
twoEmaLength = 13
threeEmaLength = 50
fourEmaLength = 200
fiveEmaLength = 800

oneEma = ta.ema(close, oneEmaLength)
plot(showEmas ? oneEma : na, color=oneEmaColor, title='5 Ema')

twoEma = ta.ema(close, twoEmaLength)
plot(showEmas ? twoEma : na, color=twoEmaColor, title='13 Ema')

threeEma = ta.ema(close, threeEmaLength)
plot(showEmas ? threeEma : na, color=threeEmaColor, title='50 Ema')

fourEma = ta.ema(close, fourEmaLength)
plot(showEmas ? fourEma : na, color=fourEmaColor, title='200 Ema')

fiveEma = ta.ema(close, fiveEmaLength)
plot(showEmas ? fiveEma : na, color=fiveEmaColor, linewidth=2, title='800 Ema')

// Ema 50 cloud placed here for readability on data window
cloudSize = ta.stdev(close, threeEmaLength * 2) / 4
p1 = plot(showEmas ? threeEma + cloudSize : na, 'Upper 50 Ema Cloud', color=emaCloudBorderColor, offset=0)
p2 = plot(showEmas ? threeEma - cloudSize : na, 'Lower 50 Ema Cloud', color=emaCloudBorderColor, offset=0)
fill(p1, p2, title='EMA 50 Cloud', color=emaCloudColor)

// Label EMAs
trLib.rLabel(oneEma, '5 Ema', label.style_none, oneEmaColor, labelEmas, labelXOffset)
trLib.rLabel(twoEma, '13 Ema', label.style_none, twoEmaColor, labelEmas, labelXOffset)
trLib.rLabel(threeEma, '50 Ema', label.style_none, threeEmaColor, labelEmas, labelXOffset)
trLib.rLabel(fourEma, '200 Ema', label.style_none, fourEmaColor, labelEmas, labelXOffset)
trLib.rLabel(fiveEma, '800 Ema', label.style_none, fiveEmaColor, labelEmas, labelXOffset)

// Detect Moving Average Contraction
ema_50 = ta.ema(close, 50)
ema_200 = ta.ema(close, 200)
ema_800 = ta.ema(close, 800)
is_contraction = math.abs(ema_50 - ema_200) < ta.stdev(close, 14)

// Detect Green Candle Crossing 50 EMA
is_green_candle = close > open
is_red_candle = close < open

// Detect Crossovers
is_cross_above_ema_50 = ta.crossover(close, ema_50)
is_long_setup = is_green_candle and is_cross_above_ema_50

is_cross_below_ema_50 = ta.crossunder(close, ema_50)
is_short_setup = is_red_candle and is_cross_below_ema_50

// Add Labels for Green Candle Crossing Above 50 EMA
if is_green_candle and is_cross_above_ema_50
    label.new(x = bar_index, y = na, text = "Green Candle Cross Above 50 EMA", color = color.new(color.green, 90), textcolor = color.white, style = label.style_label_down, yloc = yloc.belowbar, size = size.normal)

// Add Labels for Red Candle Crossing Below 50 EMA
if is_red_candle and is_cross_below_ema_50
    label.new(x = bar_index, y = na, text = "Red Candle Cross Below 50 EMA", color = color.new(color.red, 90), textcolor = color.white, style = label.style_label_up, yloc = yloc.abovebar, size = size.normal)
// pivot_points.pine

// Get Daily price data
dayHigh = f_security(syminfo.tickerid, 'D', high, false)
dayLow = f_security(syminfo.tickerid, 'D', low, false)
dayOpen = f_security(syminfo.tickerid, 'D', open, false)
dayClose = f_security(syminfo.tickerid, 'D', close, false)

// Compute Values
pivotPoint = (dayHigh + dayLow + dayClose) / 3

// Updated 2021-03-25 by infernix
pivR1 = 2 * pivotPoint - dayLow
pivS1 = 2 * pivotPoint - dayHigh
pivR2 = pivotPoint - pivS1 + pivR1
pivS2 = pivotPoint - pivR1 + pivS1
pivR3 = 2 * pivotPoint + dayHigh - 2 * dayLow
pivS3 = 2 * pivotPoint - (2 * dayHigh - dayLow)

// Plot Values
pivline = trLib.drawPivot(validTimeFrame and (showLevelOnePivotPoints or showLevelTwoPivotPoints or showLevelThreePivotPoints or activeM) ? pivotPoint : na, 'D', 'PP', pivotColor, pivotLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivr1line = trLib.drawPivot(validTimeFrame and showLevelOnePivotPoints ? pivR1 : na, 'D', 'R1', color.new(color.green, 50), color.new(color.green, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelOnePivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivs1line = trLib.drawPivot(validTimeFrame and showLevelOnePivotPoints ? pivS1 : na, 'D', 'S1', color.new(color.red, 50), color.new(color.red, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelOnePivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivr2line = trLib.drawPivot(validTimeFrame and showLevelTwoPivotPoints ? pivR2 : na, 'D', 'R2', color.new(color.green, 50), color.new(color.green, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelTwoPivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivs2line = trLib.drawPivot(validTimeFrame and showLevelTwoPivotPoints ? pivS2 : na, 'D', 'S2', color.new(color.red, 50), color.new(color.red, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelTwoPivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivr3line = trLib.drawPivot(validTimeFrame and showLevelThreePivotPoints ? pivR3 : na, 'D', 'R3', color.new(color.green, 50), color.new(color.green, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelThreePivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
pivs3line = trLib.drawPivot(validTimeFrame and showLevelThreePivotPoints ? pivS3 : na, 'D', 'S3', color.new(color.red, 50), color.new(color.red, 50), rsStyle, 1, extendPivots ? extend.both : extend.right, showLevelThreePivotPoints and showPivotLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)

// M Levels
m0C = (pivS2 + pivS3) / 2
m1C = (pivS1 + pivS2) / 2
m2C = (pivotPoint + pivS1) / 2
m3C = (pivotPoint + pivR1) / 2
m4C = (pivR1 + pivR2) / 2
m5C = (pivR2 + pivR3) / 2

// Draw M Levels
trLib.drawPivot(validTimeFrame and activeM and not na(m0C) ? m0C : na, 'D', 'M0', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
trLib.drawPivot(validTimeFrame and activeM and not na(m1C) ? m1C : na, 'D', 'M1', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
trLib.drawPivot(validTimeFrame and activeM and not na(m2C) ? m2C : na, 'D', 'M2', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
trLib.drawPivot(validTimeFrame and activeM and not na(m3C) ? m3C : na, 'D', 'M3', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
trLib.drawPivot(validTimeFrame and activeM and not na(m4C) ? m4C : na, 'D', 'M4', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)
trLib.drawPivot(validTimeFrame and activeM and not na(m5C) ? m5C : na, 'D', 'M5', mColor, mLabelColor, mStyle, 1, extendPivots ? extend.both : extend.right, showMLabels and validTimeFrame, validTimeFrame, levelStart, pivotLabelXOffset)

// Detect Key Levels for W and M Formations
is_key_level_w = low[1] == pivS1
is_key_level_m = high[1] == pivS1
// market_sessions.pine

// Market Sessions
[nyDST, ukDST, sydDST] = trLib.calcDst()

if ukDST
    trLib.drawOpenRange(sess1Time,sess1col,showOr1,'GMT+1')
    trLib.drawSessionHiLo(sess1Time, showRectangle1, showLabel1, sess1colLabel, sess1Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess1Time,sess1col,showOr1,'GMT+0')
    trLib.drawSessionHiLo(sess1Time, showRectangle1, showLabel1, sess1colLabel, sess1Label, 'GMT+0', rectStyle)

if nyDST
    trLib.drawOpenRange(sess2Time,sess2col,showOr2,'GMT+1')
    trLib.drawSessionHiLo(sess2Time, showRectangle2, showLabel2, sess2colLabel, sess2Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess2Time,sess2col,showOr2,'GMT+0')
    trLib.drawSessionHiLo(sess2Time, showRectangle2, showLabel2, sess2colLabel, sess2Label, 'GMT+0', rectStyle)

// Tokyo
trLib.drawOpenRange(sess3Time,sess3col,showOr3,'GMT+0')
trLib.drawSessionHiLo(sess3Time, showRectangle3, showLabel3, sess3colLabel, sess3Label, 'GMT+0', rectStyle)

// Hong Kong
trLib.drawOpenRange(sess4Time,sess4col,showOr4,'GMT+0')
trLib.drawSessionHiLo(sess4Time, showRectangle4, showLabel4, sess4colLabel, sess4Label, 'GMT+0', rectStyle)

if sydDST
    trLib.drawOpenRange(sess5Time,sess5col,showOr5,'GMT+1')
    trLib.drawSessionHiLo(sess5Time, showRectangle5, showLabel5, sess5colLabel, sess5Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess5Time,sess5col,showOr5,'GMT+0')
    trLib.drawSessionHiLo(sess5Time, showRectangle5, showLabel5, sess5colLabel, sess5Label, 'GMT+0', rectStyle)

// EU Brinks
if ukDST
    trLib.drawOpenRange(sess6Time,sess6col,showOr6,'GMT+1')
    trLib.drawSessionHiLo(sess6Time, showRectangle6, showLabel6, sess6colLabel, sess6Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess6Time,sess6col,showOr6,'GMT+0')
    trLib.drawSessionHiLo(sess6Time, showRectangle6, showLabel6, sess6colLabel, sess6Label, 'GMT+0', rectStyle)

// US Brinks
if nyDST
    trLib.drawOpenRange(sess7Time,sess7col,showOr7,'GMT+1')
    trLib.drawSessionHiLo(sess7Time, showRectangle7, showLabel7, sess7colLabel, sess7Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess7Time,sess7col,showOr7,'GMT+0')
    trLib.drawSessionHiLo(sess7Time, showRectangle7, showLabel7, sess7colLabel, sess7Label, 'GMT+0', rectStyle)

// Frankfurt
if ukDST
    trLib.drawOpenRange(sess8Time,sess8col,showOr8,'GMT+1')
    trLib.drawSessionHiLo(sess8Time, showRectangle8, showLabel8, sess8colLabel, sess8Label, 'GMT+1', rectStyle)
else
    trLib.drawOpenRange(sess8Time,sess8col,showOr8,'GMT+0')
    trLib.drawSessionHiLo(sess8Time, showRectangle8, showLabel8, sess8colLabel, sess8Label, 'GMT+0', rectStyle)

// Detect W Formation During London Session
is_london_session = time(timeframe.period, "0800-1630")
// is_w_formation_london = f_is_w_formation(high, low) and not na(is_london_session)
// Psy Levels
var int oneWeekMillis = (7 * 24 * 60 * 60 * 1000)

[psyHi, psyLo, psyHiLabel, psyLoLabel, psySessionStartTime] = trLib.calcPsyLevels(oneWeekMillis, showPsylevels, psyType, sydDST)

// Declare psyHiLine and psyLoLine outside the conditional block
var line psyHiLine = na
var line psyLoLine = na

// Draw Psy Level Lines
if (barstate.islast) and not showAllPsy and showPsylevels
    // Extend line back to the previous start time (after Psy-Hi/Lo have been calculated)
    psyHiLine := line.new(time, psyHi, psySessionStartTime, psyHi, xloc.bar_time, extend.none, psyColH)
    line.delete(psyHiLine[1])
    psyLoLine := line.new(time, psyLo, psySessionStartTime, psyLo, xloc.bar_time, extend.none, psyColL)
    line.delete(psyLoLine[1])

// Write Psy Level Labels - same label regardless if line.new or plot used
trLib.rLabelLastBar(psyHi, psyHiLabel, label.style_none, psyColH, showPsylabel, labelXOffset)
trLib.rLabelLastBar(psyLo, psyLoLabel, label.style_none, psyColL, showPsylabel, labelXOffset)

// Plot Historical Psy Level
plot(showPsy and showPsylevels and showAllPsy ? psyHi : na, color=psyColH, style=plot.style_stepline, linewidth=2, editable=false, title="Psy-Hi")
plot(showPsy and showPsylevels and showAllPsy ? psyLo : na, color=psyColL, style=plot.style_stepline, linewidth=2, editable=false, title="Psy-Lo")

alertcondition(ta.crossunder(close,psyHi) and not na(psyHi) and psyHi != 0 , "PA crossed under Psy Hi", "PA has crossed under the Psy Hi")
alertcondition(ta.crossover(close,psyHi) and not na(psyHi) and psyHi != 0  , "PA crossed over Psy Hi", "PA has crossed over the Psy Hi")
alertcondition(ta.crossunder(close,psyLo) and not na(psyLo) and psyLo != 0 , "PA crossed under Psy Lo", "PA has crossed under the Psy Lo")
alertcondition(ta.crossover(close,psyLo) and not na(psyLo) and psyLo != 0  , "PA crossed over Psy Lo", "PA has crossed over the Psy Lo")

// Detect Psychological Level Alignments
is_psy_level_w = low[1] == psyLo
is_psy_level_m = high[1] == psyHi
// vector_candles.pine

// Vector Candle Zones Configuration
int zonesMax = input.int(500, 'Maximum zones to draw', group='Vector Candle Zones', inline="vczOn")
string zoneType = input.string(group='Vector Candle Zones', defval='Body only', title='Zone top/bottom is defined with: ', options=['Body only', 'Body with wicks'])
string zoneUpdateType = input.string(group='Vector Candle Zones', defval='Body with wicks', title='Zones are cleared using candle: ', options=['Body only', 'Body with wicks'])
int borderWidth = input.int(0, 'Zone border width', group='Vector Candle Zones')
bool colorOverride = input.bool(true, 'Override color?', group='Vector Candle Zones', inline="vcz1")
color zoneColor = input.color(title='Color', group='Vector Candle Zones', defval=color.rgb(255, 230, 75, 90), inline="vcz1", tooltip='The vector candle zones color to use if you do not want to use the PVSRA Candle Colors.')
int transperancy = input.int(90, 'Zone Transparency', minval=0, maxval=100, group='Vector Candle Zones', tooltip='If the vector candle zones color is not overridden, then we want to set the transparency of the vector candle colors as defined by the PBSRA candle colors. This setting only affects the candle zone colors, not the candle colors themselves.')

// Vector Candle Zones Logic
var zoneBoxesAbove = array.new_box()
var zoneBoxesBelow = array.new_box()

[pvsraVolume, pvsraHigh, pvsraLow, pvsraClose, pvsraOpen] = pvsraVolume(overrideSym, pvsraSym, syminfo.tickerid)

// Calculate PVSRA color and other metrics
[pvsraColor, alertFlag, averageVolume, volumeSpread, highestVolumeSpread] = trLib.calcPvsra(pvsraVolume, pvsraHigh, pvsraLow, pvsraClose, pvsraOpen, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor, regularCandleDownColor, regularCandleUpColor)
barcolor(pvsraColor)

if showVCZ

    // Get PVSRA flag
    pvsraFlag = trLib.getPvsraFlagByColor(pvsraColor, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor, regularCandleUpColor)

    // Update zones above and below the price
    trLib.updateZones(pvsraFlag, 0, zoneBoxesBelow, zonesMax, pvsraHigh, pvsraLow, pvsraOpen, pvsraClose, transperancy, zoneUpdateType, zoneColor, zoneType, borderWidth, colorOverride, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor)
    trLib.updateZones(pvsraFlag, 1, zoneBoxesAbove, zonesMax, pvsraHigh, pvsraLow, pvsraOpen, pvsraClose, transperancy, zoneUpdateType, zoneColor, zoneType, borderWidth, colorOverride, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor)

    // Clean up the arrays
    trLib.cleanarr(zoneBoxesAbove)
    trLib.cleanarr(zoneBoxesBelow)

// Detect High-Volume Vector Candles
is_green_vector = volume > ta.sma(volume, 14) * volume_multiplier and close > open
is_red_vector = volume > ta.sma(volume, 14) * volume_multiplier and close < open

// Detect Vector Candle Patterns
is_vector_long_setup = is_green_vector and close > ema_50
is_vector_short_setup = is_red_vector and close < ema_50
// adr_awr_amr.pine

// ADR
[dayAdr, dayAdrHigh, dayAdrLow]  = request.security(syminfo.tickerid, 'D', trLib.adrHiLo(aDRRange,1, showADRDO), lookahead=barmerge.lookahead_on)
dayAdrHigh50 = dayAdrHigh - (dayAdr/2)
dayAdrLow50 = dayAdrLow + (dayAdr/2)

if showADR
    string hl = 'Hi-ADR'+ (showADRDO?'(DO)':'')
    string ll = 'Lo-ADR'+ (showADRDO?'(DO)':'')
    trLib.drawLine(dayAdrHigh, 'D', hl, adrColor, adrStyle, 2, extend.right, showADRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.drawLine(dayAdrLow, 'D', ll, adrColor, adrStyle, 2, extend.right, showADRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.rLabelOffset((dayAdrHigh + dayAdrLow) / 2, 'ADR ' + str.format('{0,number,#.##}', trLib.toPips(dayAdr)) + 'PIPS|' + str.tostring(dayAdr, format.mintick) + syminfo.currency, label.style_none, adrColor, showADRLabels and validTimeFrame and showADRRange, adrLabelXOffset)

if showADR and showADR50
    string hl = '50% Hi-ADR'+ (showADRDO?'(DO)':'')
    string ll = '50% Lo-ADR'+ (showADRDO?'(DO)':'')
    trLib.drawLine(dayAdrHigh50, 'D', hl, adrColor, adrStyle, 2, extend.right, showADRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.drawLine(dayAdrLow50, 'D', ll, adrColor, adrStyle, 2, extend.right, showADRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.rLabelOffset((dayAdrHigh50 + dayAdrLow50) / 2, '50% ADR ' + str.format('{0,number,#.##}', trLib.toPips(dayAdr/2)) + 'PIPS|' + str.tostring(dayAdr/2, format.mintick) + syminfo.currency, label.style_none, adrColor, showADRLabels and validTimeFrame and showADRRange, adrLabelXOffset50)

alertcondition(ta.crossover(close,dayAdrHigh) and dayAdrHigh != 0.0 , "ADR High reached", "PA has reached the calculated ADR High")
alertcondition(ta.crossunder(close,dayAdrLow) and dayAdrLow != 0.0 , "ADR Low reached", "PA has reached the calculated ADR Low")
alertcondition(ta.crossover(close,dayAdrHigh50) and dayAdrHigh50 != 0.0 , "50% of ADR High reached", "PA has reached 50% of the calculated ADR High")
alertcondition(ta.crossunder(close,dayAdrLow50) and dayAdrLow50 != 0.0 , "50% ADR Low reached", "PA has reached 50% the calculated ADR Low")

// AWR
[weekAdr, weekAdrHigh,weekAdrLow]  = request.security(syminfo.tickerid, 'W', trLib.adrHiLo(aWRRange, 1, showAWRWO), lookahead=barmerge.lookahead_on)
weekAdrHigh50 = weekAdrHigh - (weekAdr/2)
weekAdrLow50 = weekAdrLow + (weekAdr/2)

if showAWR
    string hl = 'Hi-AWR'+ (showAWRWO?'(WO)':'')
    string ll = 'Lo-AWR'+ (showAWRWO?'(WO)':'')
    trLib.drawLine(weekAdrHigh, 'W', hl, awrColor, awrStyle, 1, extend.right, showAWRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.drawLine(weekAdrLow, 'W', ll, awrColor, awrStyle, 1, extend.right, showAWRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.rLabelOffset((weekAdrHigh + weekAdrLow) / 2, 'AWR ' + str.format('{0,number,#.##}', trLib.toPips(weekAdr)) + 'PIPS|' + str.tostring(weekAdr, format.mintick) + syminfo.currency, label.style_none, awrColor, showAWRLabels and validTimeFrame and showAWRRange, adrLabelXOffset)

if showAWR and showAWR50
    string hl = '50% Hi-AWR'+ (showAWRWO?'(WO)':'')
    string ll = '50% Lo-AWR'+ (showAWRWO?'(WO)':'')
    trLib.drawLine(weekAdrHigh50, 'W', hl, awrColor, awrStyle, 1, extend.right, showAWRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.drawLine(weekAdrLow50, 'W', ll, awrColor, awrStyle, 1, extend.right, showAWRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.rLabelOffset((weekAdrHigh50 + weekAdrLow50) / 2, '50% AWR ' + str.format('{0,number,#.##}', trLib.toPips(weekAdr/2)) + 'PIPS|' + str.tostring(weekAdr/2, format.mintick) + syminfo.currency, label.style_none, awrColor, showAWRLabels and validTimeFrame and showAWRRange, adrLabelXOffset50)

alertcondition(ta.crossover(close,weekAdrHigh) and weekAdrHigh != 0 , "AWR High reached", "PA has reached the calculated AWR High")
alertcondition(ta.crossunder(close,weekAdrLow) and weekAdrLow != 0 , "AWR Low reached", "PA has reached the calculated AWR Low")
alertcondition(ta.crossover(close,weekAdrHigh50) and weekAdrHigh50 != 0 , "50% of AWR High reached", "PA has reached 50% of the calculated AWR High")
alertcondition(ta.crossunder(close,weekAdrLow50) and weekAdrLow50 != 0 , "50% AWR Low reached", "PA has reached 50% of the calculated AWR Low")

// AMR
[monthAdr, monthAdrHigh,monthAdrLow]  = request.security(syminfo.tickerid, 'M', trLib.adrHiLo(aMRRange, 1, showAMRMO), lookahead=barmerge.lookahead_on)
monthAdrHigh50 = monthAdrHigh - (monthAdr/2)
monthAdrLow50 = monthAdrLow + (monthAdr/2)

if showAMR and timeframe.isminutes and timeframe.multiplier >= 3
    string hl = 'Hi-AMR'+ (showAMRMO?'(MO)':'')
    string ll = 'Lo-AMR'+ (showAMRMO?'(MO)':'')
    trLib.drawLine(monthAdrHigh, 'M', hl, amrColor, amrStyle, 1, extend.right, showAMRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.drawLine(monthAdrLow, 'M', ll, amrColor, amrStyle, 1, extend.right, showAMRLabels and validTimeFrame, adrLabelXOffset, validTimeFrame)
    trLib.rLabelOffset((monthAdrHigh + monthAdrLow) / 2, 'AMR ' + str.format('{0,number,#.##}', trLib.toPips(monthAdr)) + 'PIPS|' + str.tostring(monthAdr, format.mintick) + syminfo.currency, label.style_none, amrColor, showAMRLabels and validTimeFrame and showAMRRange,adrLabelXOffset)

if showAMR and showAMR50 and timeframe.isminutes and timeframe.multiplier >= 3
    string hl = '50% Hi-AMR'+ (showAMRMO?'(MO)':'')
    string ll = '50% Lo-AMR'+ (showAMRMO?'(MO)':'')
    trLib.drawLine(monthAdrHigh50, 'M', hl, amrColor, amrStyle, 1, extend.right, showAMRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.drawLine(monthAdrLow50, 'M', ll, amrColor, amrStyle, 1, extend.right, showAMRLabels and validTimeFrame, adrLabelXOffset50, validTimeFrame)
    trLib.rLabelOffset((monthAdrHigh50 + monthAdrLow50) / 2, '50% AMR ' + str.format('{0,number,#.##}', trLib.toPips(monthAdr/2)) + 'PIPS|' + str.tostring(monthAdr/2, format.mintick) + syminfo.currency, label.style_none, amrColor, showAMRLabels and validTimeFrame and showAMRRange,adrLabelXOffset50)

alertcondition(ta.crossover(close,monthAdrHigh) and monthAdrHigh != 0 , "AMR High reached", "PA has reached the calculated AMR High")
alertcondition(ta.crossunder(close,monthAdrLow) and monthAdrLow != 0 , "AMR Low reached", "PA has reached the calculated AMR Low")
alertcondition(ta.crossover(close,monthAdrHigh50) and monthAdrHigh50 != 0 , "50% of AMR High reached", "PA has reached 50% of the calculated AMR High")
alertcondition(ta.crossunder(close,monthAdrLow50) and monthAdrLow50 != 0 , "50% of AMR Low reached", "PA has reached 50% of the calculated AMR Low")

// Significant Move Filter
is_significant_move = (high - low) > dayAdr * atr_threshold_multiplier

// Dynamic Take Profit and Stop Loss
take_profit = close + dayAdr
stop_loss = close - dayAdr
// === Inputs ===
webhookURL = input.string("https://your-api-endpoint.com/webhook", title="Webhook URL")

// === Volume Spike ===
is_volume_spike = volume > avg_volume * 2

// === RSI Filter ===
rsi_value = ta.rsi(close, 14)
is_rsi_filtered_long = rsi_value < 70  // Not overbought
is_rsi_filtered_short = rsi_value > 30 // Not oversold

// === EMA Fan-Out Confirmation ===
is_ema_fanned_out = ema_50 > ema_200 and ema_200 > ema_800

// === First Green Vector Candle Above 50 EMA (Long Entry) ===
is_long_entry = is_green_vector and is_cross_above_ema_50 and is_volume_spike and is_rsi_filtered_long and is_ema_fanned_out

long_payload ='{"symbol": "' + syminfo.ticker + '", ' + '"timestamp": "' + str.tostring(time) + '", ' + '"price": ' + str.tostring(close) + ', ' + '"direction": "long", ' + '"strategy": "First Green Vector Above 50 EMA", ' + '"timeframe": "' + timeframe.period + '", ' + '"ema_50": ' + str.tostring(ema_50) + ', ' + '"ema_200": ' + str.tostring(ema_200) + ', ' + '"ema_800": ' + str.tostring(ema_800) + ', ' + '"volume": ' + str.tostring(volume) + ', ' + '"rsi": ' + str.tostring(rsi_value) + '}'

if is_long_entry
    alert(long_payload, alert.freq_once_per_bar)

// === First Red Vector Candle Below 50 EMA (Short Entry) ===
is_short_entry = is_red_vector and is_cross_below_ema_50 and is_volume_spike and is_rsi_filtered_short and is_ema_fanned_out

short_payload = '{"symbol": "' + syminfo.ticker + '", ' + '"timestamp": "' + str.tostring(time) + '", ' + '"price": ' + str.tostring(close) + ', ' + '"direction": "short", ' + '"strategy": "First Red Vector Below 50 EMA", ' + '"timeframe": "' + timeframe.period + '", ' + '"ema_50": ' + str.tostring(ema_50) + ', ' + '"ema_200": ' + str.tostring(ema_200) + ', ' + '"ema_800": ' + str.tostring(ema_800) + ', ' + '"volume": ' + str.tostring(volume) + ', ' + '"rsi": ' + str.tostring(rsi_value) + '}'

if is_short_entry
    alert(short_payload, alert.freq_once_per_bar)

// === W Formation Confirmation (Long Entry) ===

// Check if green vector candles have been recovered
is_green_vector_recovered = false
for i = 1 to 50
    if high[i] > high[i+1] and close[i] > open[i] and volume[i] > ta.sma(volume, 14)[i] * 2
        is_green_vector_recovered := true
        break

is_w_confirmation = is_w_formation and is_green_vector_recovered and close > high[1] and is_volume_spike and is_rsi_filtered_long and is_ema_fanned_out

// Calculate W Formation Size
w_formation_height = high[1] - low[1]  // Height of the W formation
w_estimated_move = w_formation_height * 1.5  // Estimated move (1.5x the height)

w_payload = '{"symbol": "' + syminfo.ticker + '", ' + '"timestamp": "' + str.tostring(time) + '", ' + '"price": ' + str.tostring(close) + ', ' + '"direction": "long", ' + '"strategy": "W Formation Confirmation", ' + '"timeframe": "' + timeframe.period + '", ' + '"w_formation_height": ' + str.tostring(w_formation_height) + ', ' + '"w_estimated_move": ' + str.tostring(w_estimated_move) + ', ' + '"ema_50": ' + str.tostring(ema_50) + ', ' + '"ema_200": ' + str.tostring(ema_200) + ', ' + '"ema_800": ' + str.tostring(ema_800) + ', ' + '"volume": ' + str.tostring(volume) + ', ' + '"rsi": ' + str.tostring(rsi_value) + '}'

if is_w_confirmation
    alert(w_payload, alert.freq_once_per_bar)

// === M Formation Confirmation (Short Entry) ===
// Check if red vector candles have been recovered
is_red_vector_recovered = false
for i = 1 to 50
    if low[i] < low[i+1] and close[i] < open[i] and volume[i] > ta.sma(volume, 14)[i] * 2
        is_red_vector_recovered := true
        break

is_m_confirmation = is_m_formation and is_red_vector_recovered and close < low[1] and is_volume_spike and is_rsi_filtered_short and is_ema_fanned_out

// Calculate M Formation Size
m_formation_height = high[1] - low[1]  // Height of the M formation
m_estimated_move = m_formation_height * 1.5  // Estimated move (1.5x the height)

m_payload = '{"symbol": "' + syminfo.ticker + '", ' + '"timestamp": "' + str.tostring(time) + '", ' + '"price": ' + str.tostring(close) + ', ' + '"direction": "short", ' + '"strategy": "M Formation Confirmation", ' + '"timeframe": "' + timeframe.period + '", ' + '"m_formation_height": ' + str.tostring(m_formation_height) + ', ' + '"m_estimated_move": ' + str.tostring(m_estimated_move) + ', ' + '"ema_50": ' + str.tostring(ema_50) + ', ' + '"ema_200": ' + str.tostring(ema_200) + ', ' + '"ema_800": ' + str.tostring(ema_800) + ', ' + '"volume": ' + str.tostring(volume) + ', ' + '"rsi": ' + str.tostring(rsi_value) + '}'

if is_m_confirmation
    alert(m_payload, alert.freq_once_per_bar)
